import {
  SchemaTemplateContext,
  FileOutput,
  Document,
  Operation,
  SelectionSetFieldNode,
  SelectionSetItem
} from "graphql-codegen-core/dist/types";

const capitalize = (s: string) =>
  (s[0] || "").toUpperCase() + s.slice(1, s.length);

const uncapitalize = (s: string) =>
  (s[0] || "").toLowerCase() + s.slice(1, s.length);
const getFullName = (op: Operation) =>
  capitalize(op.name) + capitalize(op.operationType);

const mappedType = (type: string) => {
  const types = {
    String: "String",
    Int: "int",
    Float: "double",
    Boolean: "bool",
    ID: "String"
  };

  if (types[type]) {
    return types[type];
  }
  return "dynamic";
};

class _ErrorLogged extends Error {
  constructor(r: string) {
    console.error(r);
    super(r);
  }
}
const ErrorLogged = (r: string) => new _ErrorLogged(r);

const processLeaf = (selection: SelectionSetFieldNode): string => {
  const { isRequired, type, name } = selection;
  if (isRequired) {
    return `${mappedType(type)} get ${name} => this._d["${name}"];`;
  } else {
    return `Option<${mappedType(
      type
    )}> get ${name} => option(this._d["${name}"]!=null, this._d["${name}"]);`;
  }
};

const declareField = (name: string, fields: SelectionSetItem[]): string => {
  const processedSet = processSelectionSet(fields, name);

  return `${processedSet.topLevel}
  class ${name} {
    ${name}(this._d);
  
    final Map<String, dynamic> _d;
  
    ${processedSet.content}
  
    String toString() {
        return this._d.toString();
    }
  }
  `;
};

const processField = (
  selection: SelectionSetFieldNode,
  parentName: string
): { content: string; topLevel: string } => {
  const { isRequired, type, name, isArray } = selection;
  const fieldType = `${parentName}${capitalize(type)}`;
  let content = "";
  if (isRequired) {
    if (isArray) {
      content = `List<${fieldType}> get ${name} => (this._d["${name}"] as List).map<${fieldType}>((${uncapitalize(
        type
      )}) => ${fieldType}(${uncapitalize(type)})).toList();`;
    } else {
      content = `${fieldType} get ${name} => ${fieldType}(this._d["${name}"]);`;
    }
  } else {
    if (isArray) {
      content = `List<Option<${fieldType}>> get ${name} => (this._d["${name}"] as List).map<Option<${fieldType}>>((${uncapitalize(
        type
      )}) => option(${uncapitalize(type)}!=null, ${fieldType}(${uncapitalize(
        type
      )}))).toList();`;
    } else {
      content = `Option<${fieldType}> get ${name} => option(this._d["${name}"]!=null, ${fieldType}(this._d["${name}"]));`;
    }
  }

  return {
    content,
    topLevel: declareField(fieldType, selection.selectionSet)
  };
};

const processSelectionSet = (
  selectionSet: SelectionSetItem[],
  parentName: string
): { content: string; topLevel: string } => {
  const _topLevel: string[] = [];

  const content = selectionSet
    .map(
      (selection): string => {
        const isSelectionSetFieldNode = (s: any): s is SelectionSetFieldNode =>
          typeof s.dimensionOfArray === "number";
        if (selection.isLeaf && isSelectionSetFieldNode(selection)) {
          return processLeaf(selection);
        } else if (selection.isField && isSelectionSetFieldNode(selection)) {
          const result = processField(selection, parentName);
          _topLevel.push(result.topLevel);
          return result.content;
        }
        throw ErrorLogged("processSelectionSet: Not implemented");
      }
    )
    .join("\n  ");
  return { content, topLevel: _topLevel.join("\n") };
};

const processVariables = (op: Operation) => {
  if (op.hasVariables) {
    const argsList = op.variables
      .map(({ type, name, isRequired }) => {
        return `${isRequired ? "@required " : ""}${mappedType(type)} ${name}`;
      })
      .join(", ");

    const body = op.variables
      .map(({ name }) => {
        return `"${name}": ${name}`;
      })
      .join("\n");

    return `Map<String, dynamic> ${uncapitalize(
      op.name
    )}Variables({${argsList}}) {
      return {
          ${body}
      };
  }`;
  }
  return "";
};

const processOperation = (op: Operation): string => {
  const processedSet = processSelectionSet(
    op.selectionSet,
    capitalize(op.name)
  );

  const variables = processVariables(op);
  return `import 'package:dartz/dartz.dart';
  import 'package:flutter/foundation.dart';
  ${variables}
  ${processedSet.topLevel}
  class ${capitalize(op.name)} {
    ${capitalize(op.name)}(this._d);
  
    final Map<String, dynamic> _d;
  
    ${processedSet.content}
  }`;
};

export default function(
  templateContext: SchemaTemplateContext,
  mergedDocuments: Document,
  settings: any
): FileOutput[] | Promise<FileOutput[]> {
  return mergedDocuments.operations.map(op => {
    return {
      filename: getFullName(op) + ".dart",
      content: processOperation(op)
    };
  });
}
